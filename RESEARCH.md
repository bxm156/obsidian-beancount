Obsidian Beancount Plugin: Feasibility & Design

Introduction & Overview

Project Goal: Develop an Obsidian.md community plugin that brings plain-text Beancount accounting into the Obsidian environment. This plugin would let users write and edit Beancount-compatible financial records directly in Markdown files, with features like inline validation, querying of financial data, and integration with external tools (e.g. Fava for reporting). The motivation is to combine Beancount‚Äôs robust double-entry accounting with Obsidian‚Äôs note-taking and organization, so users can manage finances in their vault just as easily as they take notes. All data remains in plain text (for compatibility with Beancount and other plaintext accounting tools) and within the user‚Äôs vault (for privacy), echoing the ethos of the existing Ledger plugin for Obsidian Ôøº. Key objectives include:
	‚Ä¢	Markdown-Based Ledger Files: Use standard .md notes (instead of .beancount files) to record transactions, enabling rich Markdown formatting and backlinks around the financial data.
	‚Ä¢	Beancount Syntax Integration: Embed Beancount entries in Markdown while preserving Beancount‚Äôs syntax rules (dates, accounts, amounts, etc.), possibly via code blocks or clever parsing of the markdown content.
	‚Ä¢	Inline Validation & Balance Checks: Provide feedback on accounting errors (e.g. unbalanced transactions, typos in account names) directly in the editor. The plugin should validate the Beancount ledger and flag errors or warnings inline, similar to how an IDE highlights syntax errors. This includes running balance assertions and other Beancount checks with immediate feedback.
	‚Ä¢	Querying & Reports in Obsidian: Allow users to query their financial data from within Obsidian. This could mean running Beancount queries (BQL) and displaying results in a note, or leveraging Obsidian‚Äôs Dataview plugin to filter and summarize transaction data. The goal is to generate reports (like balances, income/expense summaries, budgets) without leaving Obsidian.
	‚Ä¢	Transaction Entry UX: Simplify adding new transactions via Obsidian‚Äôs UI. Drawing inspiration from tgrosinger‚Äôs Ledger plugin Ôøº and similar tools, implement a quick-add modal or form for entering transactions (with fields for date, payee/description, accounts, amount, etc.), complete with autocomplete for account names and other shortcuts to speed up data entry.
	‚Ä¢	External Tool Integration: Optionally integrate with existing Beancount tools for advanced functionality. In particular, explore integration with Fava (the web dashboard for Beancount) ‚Äì for example, a command to launch Fava with the current ledger, or even embedding Fava‚Äôs interface in Obsidian if feasible. This would give users access to rich charts and reports.

This document explores the feasibility and implementation details for such a plugin, covering the relevant technologies, design considerations, and a proposed project structure. It references official documentation and successful open-source examples to ground the recommendations in real-world practice.

Relevant Technologies & Plugin Development Practices

Obsidian Plugin Basics (TypeScript, API, UI)

Obsidian supports a robust plugin API (in TypeScript) that allows developers to extend the app‚Äôs functionality Ôøº. Plugins run in Obsidian‚Äôs Electron environment, which means developers have access to both browser APIs and Node.js APIs (for file system access, spawning processes, etc.). Key points about the development stack and best practices include:
	‚Ä¢	TypeScript & API Definitions: Obsidian plugin development is typically done in TypeScript for type-checking and clarity Ôøº. The Obsidian team provides a obsidian.d.ts type definition file (or an obsidian-api npm package) that describes the plugin API. This includes classes like Plugin (which plugins extend), UI components (modals, settings tabs, etc.), and various events/hooks. Using the official template or sample plugin is a recommended starting point. In fact, Obsidian has an official sample plugin repository that can be used as a template, complete with a modern TypeScript setup and build config Ôøº. This ensures a VSCode-friendly environment with intellisense and documentation for the Obsidian API.
	‚Ä¢	Plugin Structure: At minimum, a plugin repository contains a manifest.json (with plugin metadata like ID, name, version, and minimum Obsidian version) and a main.ts (entry point implementing the plugin logic). The TypeScript code is transpiled to a single main.js that Obsidian loads. Most plugins follow a structure similar to the sample plugin: source files in src/, a bundler config (Rollup or esbuild) to build the code, and supporting files like package.json for dependencies. We will detail a proposed file layout in a later section.
	‚Ä¢	UI Components: The Obsidian API allows creating various UI elements:
	‚Ä¢	Ribbon icons (sidebar buttons) ‚Äì e.g. a ‚Äúüìã‚Äù or ‚Äúwallet‚Äù icon could be added to quickly open a transaction entry form.
	‚Ä¢	Commands ‚Äì actions accessible via the Command Palette (e.g. ‚ÄúAdd Beancount Transaction‚Äù, ‚ÄúValidate Beancount Ledger‚Äù, ‚ÄúOpen Fava Dashboard‚Äù). These commands can be registered in the plugin and can trigger modals or other behaviors.
	‚Ä¢	Modals & Forms ‚Äì Obsidian provides a Modal class for pop-up dialogs. This can be used to design a transaction input form. For example, the sample plugin demonstrates opening a simple modal on command Ôøº. Our plugin can extend this idea to create a form with input fields for transaction details.
	‚Ä¢	Settings Tab ‚Äì A custom settings panel in Obsidian‚Äôs Settings can allow users to configure things like the main ledger file, default currency, paths to external tools (Beancount/Fava), or formatting preferences. The sample plugin shows how to add a settings tab easily Ôøº.
	‚Ä¢	Editor Extensions ‚Äì Because Obsidian‚Äôs editor is based on CodeMirror, plugins can register editor extensions or decorations. For instance, we can highlight syntax or underline errors in the text. We can also use Obsidian‚Äôs Markdown post-processing to modify how content is rendered in preview (useful for rendering Beancount data or hiding semicolon comments, as discussed later).
	‚Ä¢	Development Workflow: Obsidian plugin dev is usually done in an isolated vault (to avoid messing up real notes) Ôøº Ôøº. Developers clone the template into the vault‚Äôs .obsidian/plugins/ folder, run npm install and npm run dev to watch for changes, and reload the plugin in Obsidian to see updates Ôøº. This fast iteration cycle (with hot reload on save in some cases) is supported by the sample‚Äôs build script. For testing, developers often rely on manual testing in the app, but it‚Äôs also possible to set up Jest or other test frameworks (some community plugins include tests for their core logic).
	‚Ä¢	Reference ‚Äì Obsidian API Use: The plugin API provides many hooks (on file open/close, on save, etc.) that we can leverage. For example, to implement inline validation, we might use the onSave event or a file watch to re-validate the ledger whenever the user saves changes. To add a new view (like a Fava webview or a dashboard), we could use the workspace‚Äôs WorkspaceLeaf to create a new pane. Understanding these API capabilities will be crucial, and we can refer to the official documentation for details Ôøº.

Overall, following the official development guide and using established patterns from existing plugins will ensure our Beancount plugin is stable and user-friendly.

Beancount and Plain Text Accounting

Beancount is a double-entry accounting system that uses plain text files to record transactions (similar to Ledger CLI or hledger, but with its own syntax and philosophy). It was inspired by Ledger but is more structured and strict in its format Ôøº. A few key points about Beancount relevant to this project:
	‚Ä¢	Beancount Syntax: Transactions are recorded with a date, optional cleared flag (*), a narration (description), and optionally a payee, followed by indented lines for each posting (account and amount). For example, a simple transaction might look like:

```
2025-06-01 * "Grocery store" "Safeway"
  Expenses:Groceries        $45.67
  Assets:Cash              
````

Each account line can optionally omit the amount for the balancing leg (as above, where Assets:Cash will be automatically $-45.67). Beancount also supports directives like option (to set file-level options), open/close (to open or close an account with a start date and perhaps initial balance), commodity (to define currencies/commodities), balance (to assert an account‚Äôs balance at a certain date), pad (to automatically balance accounts), note (to attach notes to transactions), etc. The syntax is strict ‚Äì any line that doesn‚Äôt conform will cause a parse error. Unlike Ledger/hledger, which are a bit more free-form, Beancount‚Äôs rigid structure is ‚Äúlike a markup language‚Äù Ôøº. This has pros and cons: it catches errors early, but it means that extraneous text (like random Markdown headings) is not allowed unless commented out.

	‚Ä¢	Plain Text and Interoperability: One reason to use plaintext accounting is that your data remains in a portable, human-readable format. The Obsidian Ledger plugin leveraged this by keeping all data in plain .ledger files, fully compatible with external CLI tools Ôøº. Our plugin should do the same for Beancount: the financial data in the vault should be usable outside Obsidian with standard Beancount tools. This means we must ensure that the content of the Markdown files can be parsed by Beancount (perhaps after some preprocessing, discussed later). By adhering to Beancount‚Äôs format, users can at any time run beancount or open Fava on their vault‚Äôs data and get correct results. It also means freedom from proprietary formats ‚Äì the user ‚Äúowns‚Äù their financial data in a plain text form.
	‚Ä¢	Beancount‚Äôs Python Toolkit: Beancount is implemented in Python, and it comes with useful command-line utilities:
	‚Ä¢	bean-check ‚Äì checks the ledger file for errors (syntax errors, unmatched transactions, balance assertion failures, etc.).
	‚Ä¢	bean-query ‚Äì runs SQL-like queries (Beancount Query Language, BQL) on the ledger for custom reports.
	‚Ä¢	fava ‚Äì a web dashboard (also written in Python) that provides a rich UI for the ledger (graphs, charts, account drill-downs, etc.). Fava is a major advantage of using Beancount Ôøº; many users rely on it for visualizing data.
Because these tools are external, our plugin may interface with them by spawning processes if Python/Beancount is installed. Notably, Fava integration would allow users to see their data in an interactive web interface. In the plaintextaccounting community, a common workflow is to edit ledger files in a text editor and periodically view them in Fava for reports Ôøº. Some Obsidian users already do this manually: one user described how they maintain Beancount data in Obsidian and use Fava to render an income statement and other reports Ôøº. Automating this integration will greatly enhance usability.
	‚Ä¢	Ledger vs Beancount Differences: It‚Äôs worth noting differences between Beancount and the Ledger format because existing Obsidian solutions (like the Ledger plugin or hledger plugin) might not directly apply. Beancount is stricter (requiring explicit syntax) and has features like hierarchical accounts (denoted by colons), commodities (currencies), and tags/metadata on transactions. For example, Beancount supports tagging transactions with #tag or meta: "value" lines, which wouldn‚Äôt be recognized in Ledger. Our plugin must handle these elements in the editor (e.g., syntax highlighting for tags and metadata). On the flip side, Beancount doesn‚Äôt allow arbitrary text in the file ‚Äì everything must be a valid directive or comment. This rigidity will influence how we allow Markdown formatting (more on this in the next section).
	‚Ä¢	Community & Resources: We have rich resources to guide us. The official Beancount docs include a design overview and a detailed syntax guide Ôøº. The plaintextaccounting.org site is a great reference for techniques and comparisons of plaintext accounting tools Ôøº. There‚Äôs also an ecosystem of open-source code we can learn from: for instance, a tree-sitter grammar for Beancount (for syntax parsing/highlighting) and a Rust library for Beancount parsing Ôøº Ôøº. While we might not incorporate those directly, they indicate that parsing Beancount in non-Python languages is possible and some groundwork exists.

In summary, Beancount provides a solid foundation for plaintext finance tracking, and our goal is to harness its power inside Obsidian. Next, we discuss how to bridge the gap between Beancount‚Äôs file format and Obsidian‚Äôs Markdown environment.

Existing Solutions & Inspiration

Before designing our plugin, it‚Äôs useful to look at existing tools for plaintext accounting in Obsidian or similar contexts:
	‚Ä¢	Ledger Plugin (tgrosinger/ledger-obsidian): This established Obsidian plugin targets the Ledger CLI format. It demonstrates that plaintext accounting can be integrated into Obsidian‚Äôs UX. Notable features include a quick transaction entry widget, auto-suggestion of past account names, and a Ledger dashboard view Ôøº Ôøº. For example, the plugin adds a command ‚ÄúAdd to Ledger‚Äù which opens a modal form for a new transaction and appends it to a .ledger file Ôøº. It also registers .ledger files to open in a custom ‚Äúledger dashboard‚Äù view within Obsidian Ôøº. The Ledger plugin‚Äôs approach confirms we can manage a plaintext journal in Obsidian and even create custom reading views. However, it primarily works with .ledger files and its reporting feature was still in progress. Our Beancount plugin can take inspiration from it, especially for the transaction input UX and how it stores data. The principle of ‚Äústore data in plain text and keep it interoperable‚Äù is one we will continue Ôøº.
	‚Ä¢	Quick Transaction Entry UX: A standout feature of the Ledger plugin is its pop-up form for quickly adding transactions. This is exactly the kind of user experience we want for Beancount as well ‚Äì it spares the user from manually typing every component of a transaction (which can be slow, especially on mobile). The form includes fields like date (with default to today), description, amount, and account pickers, and it can suggest or autocomplete previously used accounts and payees Ôøº. This speeds up data entry and reduces errors (since account names must match exactly each time). We have a reference design in that plugin that we can mirror.

The Ledger plugin demonstrates a quick-add transaction modal in Obsidian. In the Add Transaction form (shown above), the user can fill in details (date, payee/description, amount, from/to accounts) with autocomplete for accounts to ensure consistency. This convenient UI (available on desktop and mobile) significantly speeds up logging expenses Ôøº. Our Beancount plugin can implement a similar form-driven workflow for adding entries. We will adapt it to Beancount‚Äôs specifics (e.g. multi-currency amounts, payee field, transaction flags) and then insert the formatted transaction text into the Markdown ledger file.
	‚Ä¢	Obsidian Hledger Notes Plugin: Very recently (May 2025), a plugin called Hledger Notes was released Ôøº. This plugin targets hledger (a Ledger variant) and focuses on integrating finance tracking with daily notes. Its features include:
	‚Ä¢	Fuzzy account name suggestions based on an accounts file (or existing accounts) Ôøº.
	‚Ä¢	Automatic balance calculation while entering transactions (likely to ensure the credits equal debits as you fill the form) Ôøº.
	‚Ä¢	Support for multiple currencies and shortcuts for large numbers (e.g. typing ‚Äú5k‚Äù auto-expands to 5,000) Ôøº.
	‚Ä¢	Daily Notes integration: It can automatically detect the date from the daily note‚Äôs title and group that day‚Äôs transactions in a section of the note Ôøº. Later, it can export those transactions to a formal journal file or import from the journal into daily notes Ôøº.
This plugin‚Äôs approach is very relevant to our goals. It shows one way to use Markdown files for entry (daily notes as a staging area) and then sync with a ledger file. Our plugin could offer a mode to use daily notes for daily expense capture (with automatic dating), which then get consolidated. However, we might also allow writing directly in one big file. Either way, the idea of integrating with a user‚Äôs daily note workflow is powerful (finance tracking becomes part of their daily journaling routine). The Hledger Notes plugin is open source, so we can study its implementation (e.g., how it parses the Hledger journal, how it performs import/export, how it implements fuzzy search). Many of its features (fuzzy search, multi-currency, shorthand notations) would be equally valuable for Beancount users Ôøº.
	‚Ä¢	Obsidian Beancount (hamsterbase/obsidian-beancount): This is a smaller project (beta plugin) that specifically targets Beancount Ôøº. According to its README, it allows using Obsidian (especially on mobile) to append transactions to a Beancount file Ôøº. The user configures the ‚Äúmain Beancount file‚Äù in settings, and the plugin will handle included files automatically Ôøº. There‚Äôs a UI button (a ‚Äúwallet‚Äù icon) to save a new transaction entry Ôøº. It also mentions ‚Äúsupports parsing Beancount files, retrieving Account, Commodity, Payee‚Äù Ôøº ‚Äì implying it reads the ledger to provide autocompletion for account names, list of commodities (currencies), and known payees. This is essentially the Beancount analog of the Ledger plugin‚Äôs basic features, although it appears to be focused on appending transactions rather than editing within Markdown. We can take note of how it ‚Äúparses‚Äù the file ‚Äì likely via simple text parsing rather than a full Beancount engine, but enough to grab account names and payees for suggestions.
	‚Ä¢	Plaintext Accounting User Workflows: Apart from official plugins, some users have crafted their own solutions:
	‚Ä¢	The Reddit user who used Obsidian Modal Form plugin to create a custom transaction form for Beancount is one example Ôøº Ôøº. They kept their ledger in a Markdown file and used the form plugin to insert properly formatted lines. They then processed the .md with Beancount and Fava externally. This underscores the demand for using Markdown files and hints that many people just treat the .md as if it were a .beancount (i.e., they don‚Äôt include a lot of other markdown syntax that would break Beancount).
	‚Ä¢	Another example is using the Dataview plugin to query a Ledger file. In a Medium article, Geet Duggal described how he combined a Ledger journal with Dataview JS code to compute account balances and display a summary table in Obsidian Ôøº. Dataview allows executing arbitrary JavaScript in a note, so he wrote a mini-parser in JS to read the ledger file and aggregate balances Ôøº. This approach proves that even without a dedicated plugin feature, one can pull ledger data into Obsidian for analysis. It‚Äôs a bit technical for the average user, but it‚Äôs something our plugin could simplify with built-in query support (or by providing a utility that Dataview can call).

Informed by these examples, we can outline a path forward that combines the best ideas: Ledger plugin‚Äôs UI/UX for quick entry, Hledger Notes‚Äô daily note integration and import/export, Hamsterbase‚Äôs Beancount-specific parsing, and Dataview‚Äôs querying for reports. Next, we address how to actually embed and manage Beancount content inside Markdown files.

Embedding Beancount in Markdown Files

One of the core requirements is to use Markdown .md files (instead of .bean or .beancount files) to store the accounting data. This has several advantages ‚Äì the files can live alongside other notes, you can intermix commentary or headlines, and you get all of Obsidian‚Äôs features (backlinks, tags, etc.) in your ledger. However, it presents a challenge: standard Beancount parsers will choke on non-Beancount content. We need strategies to make Beancount and Markdown coexist gracefully. Below are possible approaches:

1. Use Comments or Preprocessing for Non-Ledger Text

Beancount treats any line starting with a semicolon (;) as a comment. We can exploit this by turning markdown elements into comments so that Beancount will ignore them. For example:
	‚Ä¢	If a user writes a section heading in Markdown like ## January 2025, the plugin could automatically prefix it with ; when saving or when running validations, effectively storing it as ; ## January 2025 in the file. Obsidian would normally not render a commented line as a heading, but we can use a post-processing trick: the plugin can detect lines that start with ; ## in preview and render them as heading text (strip the semicolon for display). This way, the user sees a nice ‚ÄúJanuary 2025‚Äù header in Obsidian, but the actual file content is a Beancount comment (ignored by the Beancount parser). A similar approach was taken by Beancount‚Äôs Emacs mode: it interprets lines with ;;; or * as section headers for navigation, even though those are comments in Beancount Ôøº. We can follow that pattern.
	‚Ä¢	For any explanatory text the user wants to include (not part of a transaction), we can encourage prefixing it with ; to make it a Beancount comment. Or the plugin could automatically treat lines that don‚Äôt match any known Beancount directive as comments. For example, a sentence like ‚ÄúThis section covers reimbursements.‚Äù could be silently prefixed with ; under the hood. Alternatively, we could require the user to put an explicit ; at the start to indicate ‚Äúthis is a comment to Beancount.‚Äù

Using comments ensures that when we feed the file to the Beancount engine, it won‚Äôt complain about those lines. The downside is that comments won‚Äôt render as nicely in Obsidian preview by default (Obsidian will show the ; and treat the line as plain text). So, implementing a custom renderer for these lines would be key to make the user experience smooth. This is feasible via Obsidian‚Äôs Markdown post-processing API (we can transform the HTML after markdown render). For instance, the plugin can find <span>;</span><span>## January 2025</span> in the HTML and convert it to a <h2>January 2025</h2> element in preview.

In summary, the plugin could act as a translator between the Markdown view and the Beancount text:
	‚Ä¢	In edit mode, the user might see and type actual Markdown (without semicolons).
	‚Ä¢	Before saving or validating, the plugin inserts ; where needed.
	‚Ä¢	In preview mode, the plugin removes those ; to show formatted text.

This approach lets users embed headings, bullet lists, or narrative in their financial notes, enriching the context of their records (e.g., a narrative section for ‚ÄúYear-End Summary‚Äù could be a Markdown section that Beancount will skip over as comments).

2. Code Fences for Beancount Sections

Another approach is to isolate Beancount entries inside Markdown code blocks. For example, a user‚Äôs note could be mostly normal Markdown, and whenever they want to include transactions, they put:

```
	```beancount
	2025-06-01 * "Grocery store" "Safeway"
	Expenses:Groceries  $45.67
	Assets:Cash

	2025-06-02 * "Salary"
	Assets:Bank:Checking  $2000.00
	Income:Salary
	```
```
In the above, we use a triple-backtick code fence with a language tag `beancount`. We can create a syntax highlighting definition for `beancount` so that inside these fences, the text is colorized appropriately (there might already exist highlight definitions we can adapt [oai_citation:45‚Ä°lencerf.github.io](https://lencerf.github.io/post/2017-03-10-vscode-beancount/#:~:text=VSCode%20extension%20for%20Beancount%20,alignment%2C%3B%20Current%20time%20quick)). Obsidian will treat everything inside as literal (no markdown formatting), so we don‚Äôt have to worry about headings or lists breaking the syntax. We can then have the plugin parse and validate the content of these code blocks specifically.

However, using code blocks has some disadvantages:
- The entire ledger would need to be inside code blocks to be parsed, meaning the user might have one giant code block containing their ledger or many code blocks for different sections. One giant block per file is workable (then the whole file is basically a beancount snippet), but editing large code blocks in Obsidian can be slightly less convenient (the editing experience in a large code fence is not as fluid as normal text, and you don‚Äôt get live preview of that content since it‚Äôs always monospaced text). 
- Also, Obsidian‚Äôs search and linking won‚Äôt parse inside code blocks (for instance, if a user writes an internal link like `[[2025-06 Statement]]` inside a code block, it might not auto-update if the link target changes).
- It also visually separates the transactions from the rest of the note (some users might actually prefer them inline with the text, not in a gray box).

We could mitigate some of these by building a *custom editor view* for Beancount sections ‚Äì e.g., when a user clicks on a fence in preview, it could open a special pane (like the Ledger plugin‚Äôs dashboard view) that shows a more readable format or allows editing via a form. But this adds complexity.

A variant of this approach is to allow both: if a file‚Äôs entire content is mainly Beancount, the user could choose to name it with a `.beancount` extension or use code fences for portions. Perhaps a simpler rule: **if a file has the frontmatter or an indicator that ‚Äúthis is a Beancount ledger‚Äù, the plugin will treat the whole file content as ledger text (with comment insertion as needed)**. If the user wants to mix, they could wrap ledger parts in fences or use the commenting method.

### 3. Dedicated Vault or Folder (Optional)  
Some users might keep their financial records separate from regular notes. As an implementation detail, we could say that all files in a certain folder (e.g., `Finance/`) are to be treated as Beancount files (even if they have `.md` extension). The plugin could then operate on that folder: validate all .md files in Finance together as one ledger (since Beancount can include multiple files). We could support an `include` mechanism: e.g., the user defines a main file that includes all yearly files, or the plugin automatically considers each file as included. This way, the user can have one file per year or per month for easier management, and the plugin will combine them for reports. This is similar to how one might structure plain Beancount (multiple files with includes) and aligns with how hamsterbase‚Äôs plugin asks for a main file and auto-handles includes [oai_citation:46‚Ä°github.com](https://github.com/hamsterbase/obsidian-beancount#:~:text=1,plugin%20will%20automatically%20handle%20includes).

In Markdown, we can simulate the include by either literally writing `include "2025.md"` in the file (and having the plugin preprocess that to actual content), or by the plugin knowing to feed all relevant files to the parser. The user likely wouldn‚Äôt write the include directives in Markdown (since that line would be seen by Obsidian as text, unless commented). Instead, maybe a YAML frontmatter in the main file could list the includes, or the plugin‚Äôs settings could have a pattern.

For simplicity, initial implementation might just use one file or manually manage includes, but it‚Äôs worth noting the possibility of multiple files. It enables separation of concerns (and easier diffing if using git).

### 4. Syntax Highlighting and Editing Experience  
No matter which embedding approach we use, providing **syntax highlighting** for Beancount content in the editor will greatly improve usability. We can integrate a Beancount grammar for CodeMirror:
- If Obsidian (by 2025) supports CM6 customization, we could attempt to integrate a **Tree-sitter** parser or define a simple language mode for beancount. There is a tree-sitter grammar available [oai_citation:47‚Ä°github.com](https://github.com/polarmutex/tree-sitter-beancount#:~:text=a%20tree,Branches%3A%20Tags%3A%20Activity%3A%20Star%3A%20Notifications), which could help identify tokens (dates, account names, numbers, comments, etc.). 
- Alternatively, we can adapt an existing VSCode Beancount extension‚Äôs regex rules for highlighting. For instance, the VSCode Beancount extension (Lencerf‚Äôs) had syntax files (likely YAML or JSON defining regex patterns) [oai_citation:48‚Ä°lencerf.github.io](https://lencerf.github.io/post/2017-03-10-vscode-beancount/#:~:text=I%20wish%20to%20thank%20Chris,Beancount%20sytax%20file%20with%20me). We might be able to reuse those patterns for highlighting within Obsidian‚Äôs editor.
- Indentation rules: Usually, postings are indented by at least one or two spaces. We could implement an auto-indent feature so that when the user presses Enter after a transaction line, it auto-indents the next line (for the next posting). VSCode‚Äôs extension did something similar (auto indent postings) [oai_citation:49‚Ä°lencerf.github.io](https://lencerf.github.io/post/2017-03-10-vscode-beancount/#:~:text=,for%20a%20new%20posting%20record).
- Auto-alignment of decimal points is a nice-to-have (some editors line up the amounts for readability). This might be complex to do in Obsidian‚Äôs editor without a lot of low-level work, so we might skip it or only do it in preview.

In **preview mode**, beyond rendering comments nicely, we could also enhance the display of transactions. For example, we might render a table of postings for a transaction or add subtle styling (like making account names bold or indenting postings in preview for clarity). This is optional polish, but since the user mentioned ‚ÄúMarkdown-enhanced display and interaction,‚Äù we should consider ways to make the ledger more readable or interactive in preview. Perhaps clicking an account name could trigger opening a query showing that account‚Äôs transactions, etc. These interactive enhancements could come in later versions.

To summarize this section: **It is feasible to use Markdown files for Beancount data**, but we must carefully handle the Markdown vs. Beancount syntax differences. The most straightforward strategy is to treat non-Beancount lines as comments (so the ledger remains valid) and possibly provide a mechanism (like code fences or a designated folder) to identify which files contain ledger data. With syntax highlighting and some behind-the-scenes preprocessing, the user can enjoy the best of both worlds: writing in Markdown and maintaining a correct Beancount ledger.

## Validation & Inline Error Feedback

One of the plugin‚Äôs selling points should be the ability to **validate the ledger and catch errors early**. Normally, with plain files, you‚Äôd run `bean-check` manually to see if everything is consistent. In Obsidian, we can automate this and even integrate it into the editing UI.

### Running Beancount‚Äôs Validation  
The most reliable way to validate a Beancount file is to use Beancount‚Äôs own parser (since it understands all the rules and will produce informative error messages). There are a few ways we could do this:

- **Call `bean-check` (External Process):** If the user has Beancount installed (a Python package), the plugin can invoke `bean-check file.bean` in the background. Obsidian plugins can use Node‚Äôs `child_process.exec` or `spawn` to run external commands, since it runs in an environment with Node integration. We‚Äôd have to capture the output. `bean-check` exits with non-zero status if there are errors, and outputs each error with file name and line number. For example, an error might be:  
  `ERROR <file>.bean:123 Unbalanced Transaction: ...`  
  We can parse these strings to gather error locations. We would likely run the check on a temporary file that we generate (for example, if we‚Äôre doing Markdown preprocessing to add semicolons for headings, we‚Äôd create a temp file that is a valid .beancount and run the checker on that). If the user‚Äôs ledger spans multiple files, we‚Äôd run on the main file which includes others, or cat them together for the check.  

  This approach leverages all of Beancount‚Äôs intelligence ‚Äì it will catch typos in account names (if an account is used before being opened, or one letter off from an existing account, it warns), it will catch imbalance, missing commodity declarations, etc. The downside is it introduces a dependency on the external environment (Python and Beancount). We can mitigate friction by adding a plugin setting where the user specifies the path to their `bean-check` or Python interpreter if needed. Many Beancount users likely have it installed anyway, and we can detect common scenarios (perhaps try running `bean-check` directly if in PATH). For those who don‚Äôt, we can guide them to install it. This is similar to how some Obsidian plugins integrate with external tools (e.g., a Pandoc plugin might require Pandoc installed, etc.).

- **Bundling a Parser/Validator:** If relying on an external command is not ideal, an alternative is bundling a Beancount parser in the plugin. As mentioned earlier, there‚Äôs a **Rust library** for Beancount parsing [oai_citation:50‚Ä°docs.rs](https://docs.rs/beancount-parser/latest/beancount_parser/#:~:text=beancount_parser%20,generic%20over%20the%20decimal%20type) and possibly we could compile that to WebAssembly and include it. That library might not cover the full semantic validation (like double-entry balancing) unless it also does evaluation. Another possibility is using the **tree-sitter-beancount** grammar in combination with some custom logic: we could parse the file into a syntax tree and then implement checks (like summing postings per transaction to ensure they sum to zero, verifying that all accounts have an open directive, etc.). However, that is a significant implementation effort and would essentially re-write Beancount‚Äôs logic in TS or WASM. It might be something to consider long-term (for offline, cross-platform completeness), but in the short term, calling `bean-check` is far simpler and leverages a well-tested engine.

- **Manual/Heuristic Validation:** In addition to or instead of full parsing, we can implement quick heuristic checks in the editor:
  - For example, as the user types a transaction, once they complete it (maybe on blur or on demand), we can check if the debits and credits sum to zero (just by looking at the numbers and signs in that transaction). If not, mark it as unbalanced.
  - If a line starts with an account name that doesn‚Äôt exist yet (no corresponding open or usage elsewhere), we might flag it (though Beancount itself doesn‚Äôt require explicit account definitions aside from `open`, but it‚Äôs good practice to open accounts).
  - We could also detect common format mistakes (like forgetting to indent postings, or a missing quote in a payee name) with regex. These could provide instant feedback as red underlines, even before running a full `bean-check`.
  
  However, these are supplementary. The authoritative check is to actually parse and run the numbers via Beancount.

### Inline Error Display  
Once errors or warnings are identified (via any method above), the plugin should present them to the user in context. Options for doing so:
- **Editor Annotations:** Obsidian‚Äôs editor (CM6) supports decorations and tooltips. The plugin can mark a range of text (e.g., the line with an error) with a red underline or a red squiggly line. It can also register a hover tooltip or an icon at the line end that, when clicked or hovered, shows the error message (e.g., ‚ÄúUnbalanced Transaction: Total != 0‚Äù). This is analogous to how an IDE like VSCode shows linter errors in code. Implementing this will likely involve using the `Editor.cm` (CodeMirror) interfaces provided by the API ‚Äì possibly the `Editor.markSpan` or similar methods, or by directly accessing the CM view and adding decorations.

- **Error Pane or Status Bar:** Additionally, a summary of errors could be shown in a sidebar pane or in Obsidian‚Äôs status bar. For instance, after a validation run, the status bar could display ‚Äú‚úî Ledger balanced‚Äù or ‚Äú‚ùå 3 errors in ledger (click for details)‚Äù. Clicking could open a panel listing the errors and their locations, allowing the user to jump to each. This might be useful for a quick overview, especially if multiple errors exist across a large file.

- **Real-time vs On-Demand:** We should decide when validation occurs. Running `bean-check` on every keystroke is impractical (too slow). A good strategy: perform a full validation when the user saves the file (Ctrl+S or when switching away from the note). Obsidian fires a `onSave` event we can hook into. We could also have a command ‚ÄúValidate Now‚Äù that they can trigger. If the file is small or the user‚Äôs machine is fast, we might even do a delayed validation (e.g., 2 seconds after the last keystroke, if the user is idle). But initial implementation can stick to on-demand or on-save checks.

- **Visual Balance Checks:** Beyond error highlighting, we might implement a feature to show running balances or sums inline. For instance, some accounting editors show the balance of an account after a transaction right in the text. This might be more relevant for a register view, which is not our focus. But one thing we could do: if a `balance` assertion directive is present, visually mark whether it‚Äôs satisfied or not (green checkmark vs red cross next to it). Or if the user hovers over an account name, show the current balance of that account (as of the end of the file). These are nice-to-haves that leverage querying functionality (would require computing balances, possibly by calling bean-query or doing it in memory). They can be added once basic functionality is working.

In summary, **feasibility of validation is high**: using `bean-check` via a child process is straightforward and gives thorough results [oai_citation:51‚Ä°reddit.com](https://www.reddit.com/r/ObsidianMD/comments/1hqbyh6/do_you_like_ledger_plugin_what_do_you_think_about/#:~:text=However%2C%20when%20comparing%20the%20Ledger,%28see%20Discussion%20on%20Github). The plugin just needs to parse the output and map it to the document. The main work will be integrating with the editor to display errors, but that is well within what Obsidian‚Äôs API allows (many code-focused plugins do similar things).

## Querying Beancount Data Inside Obsidian

Having our data in Obsidian opens up possibilities to query and analyze it without leaving the app. There are a few paths to enable querying:

### 1. Built-in Query Blocks or Commands  
We can introduce a custom ** code block** in Markdown for queries, say ```bql or ```beancount-query. Users could write a query in it, for example:  

SELECT account, sum(position) 
WHERE account ~ "Expenses" 
  AND year = 2025
GROUP BY account

When the note is rendered (in preview), the plugin would detect this code block and execute the query against the user‚Äôs ledger data, then replace the block with a formatted result (perhaps a Markdown table of account and sum). This is analogous to how the Dataview plugin works with `dataview` or `dataviewjs` code blocks. We would essentially serve as a query engine.

To implement this, we again have two main choices:
- Use Beancount‚Äôs own query capability (`bean-query`). We can call `bean-query ledger.beancount "<query>"` via child process and capture the output. Bean-query can output in CSV or plain text table. We‚Äôd likely want CSV or JSON (if supported) and then format it nicely in Markdown. The advantage is full BQL support out of the box (including things like joins on tables, if any).
- Implement our own limited querying. For instance, we could load the ledger data into a JavaScript structure (list of transactions and postings) and then allow some pre-defined queries (like ‚Äúbalance sheet‚Äù, ‚Äúincome statement‚Äù, or simple filter by tag/account). This is more work and less flexible than BQL, so leaning on bean-query is preferable for comprehensive support.

The plugin could provide a few **pre-canned reports** accessible by commands or buttons (for users not comfortable writing SQL-like queries). For example, a ‚ÄúShow Income Statement‚Äù command could internally run a known query (or use Fava‚Äôs logic via bean-query templates). But exposing the raw query ability gives power users the full range.

### 2. Integration with Dataview  
If we don‚Äôt want to write a full query UI, we can exploit Dataview‚Äôs script capability. For instance, we could document for users how to do what Geet did in the Medium article [oai_citation:52‚Ä°medium.com](https://medium.com/@geetduggal/the-power-of-obsidian-for-personal-finance-accounting-f00bbcb1b66f#:~:text=visualization%20in%20a%20mobile,plugin%20to%20do%20just%20that) ‚Äì basically, read the ledger file and compute things in a `dataviewjs` block. To make it easier, the plugin can expose an interface or global function. Perhaps the plugin could add something to the global context like `app.plugins.plugins["beancount-plugin"].ledgerData` which is an array of transactions or a ready-made function like `getAccountBalance("Assets:Bank")`. Then in a dataview JS code block, a user could do: 

```js
const ledger = app.plugins.plugins["beancount-plugin"].ledger;
dv.table(["Account", "Balance"], ledger.getBalances("Assets"));
``` 

This is somewhat hacky and couples our plugin with Dataview, but it is an approach to consider for advanced users. A cleaner approach might be for our plugin to directly integrate or borrow from Dataview‚Äôs API (if Dataview exposes an API to other plugins, which I‚Äôm not sure it does). Alternatively, we could coordinate with Dataview by writing ledger data to a JSON file in the vault that Dataview could read. For example, after each validation, output an intermediate JSON with accounts and balances. Then the user could use Dataview‚Äôs normal JSON reading capabilities (if any) to query it. However, this is probably over-complicating it.

### 3. UI for Queries and Reports  
In addition to inline queries in notes, we could provide a **Query UI** in the plugin settings or commands:
- A simple ‚ÄúRun Query‚Äù command that opens a prompt where the user types a BQL query and the result is shown in a modal or new note.
- A predefined ‚ÄúBalance Sheet‚Äù or ‚ÄúIncome Statement‚Äù view that when triggered calculates those (these are essentially specific queries grouping by account categories).
- Possibly, a **dashboard view** (like Ledger plugin‚Äôs dashboard) which could show some key numbers: current total assets, net worth, recent transactions, etc., updating in real-time. This is similar to what Fava‚Äôs front page does, but we could mimic a lightweight version inside Obsidian. For instance, the Ledger plugin‚Äôs planned ‚ÄúReporting‚Äù feature likely aimed to have such summary panels.

Given the scope, we might not implement a full dashboard at first. But enabling queries sets the stage for it. A user could embed an ‚Äúoverview‚Äù note in Obsidian that contains multiple `beancount-query` blocks (one for net worth, one for expenses by category this month, etc.), essentially building their own dashboard within a note.

### 4. Performance Considerations  
Running queries on a large ledger could be slow if done frequently. If using `bean-query`, it starts a Python process each time, which has some overhead. Caching could help: the plugin might cache the parsed ledger in memory (if using an internal parser) or cache query results for a given state of the file. However, since finances typically aren‚Äôt enormous data (a few thousand transactions at most for personal use), performance should be acceptable. We can also mitigate by not running queries unless needed (e.g., only when a query block is in view, or when the user explicitly refreshes it).

In conclusion, providing **querying inside Obsidian is feasible** and very powerful. We will likely implement a combination of approaches: a straightforward code-block query feature for those who know BQL, and some helper commands or documented recipes for common use cases (possibly leveraging Dataview for advanced customizations). This turns Obsidian into not just a ledger editor but a mini analysis tool for the user‚Äôs own financial data [oai_citation:53‚Ä°medium.com](https://medium.com/@geetduggal/the-power-of-obsidian-for-personal-finance-accounting-f00bbcb1b66f#:~:text=The%20dataview%20plugin%20is%20powerful,data%20pipeline%20of%20three%20steps).

## Integrating Fava for Visualization & Reporting

**Fava** is a web dashboard for Beancount that many users love for its interactive reports (balance sheets, income statements, graphs over time, etc.). Integrating Fava into Obsidian can significantly enhance the plugin, but it comes with technical considerations.

### Option 1: Launch Fava Externally  
The simplest integration: provide a command (e.g., ‚ÄúOpen in Fava‚Äù) that will start the Fava server and open it in the user‚Äôs web browser. Steps:
- The user specifies in settings the path to their Beancount main file (or we already know it) and optionally the path to Fava (if not just a normal `fava` in PATH).
- When the command is invoked, the plugin runs `fava /path/to/main.bean` (perhaps with `--port  terminal, which may not be ideal. But on desktop, we could use Node‚Äôs ability to open a URL: `require('electron').shell.openExternal("http://localhost:XYZ")` to open the system browser to Fava‚Äôs address. The plugin could display a notice like ‚ÄúFava is running at http://localhost:XYZ ‚Äì opened in your browser.‚Äù 

This approach is straightforward and ensures the user gets the full Fava experience in their default browser. The downside is it‚Äôs not ‚Äúinside Obsidian‚Äù ‚Äì it switches context. Also, we have to manage stopping the Fava server when not needed (or maybe let it run until user closes it manually by stopping the process).

We should also consider if the user already runs Fava separately; maybe they just want a quick way to launch it from Obsidian.

### Option 2: Embed Fava in Obsidian (Webview/Iframe)  
For a more integrated feel, we could try to embed the Fava interface inside an Obsidian pane. Obsidian doesn‚Äôt officially expose a webview component, but plugins can create new panes and set their content. If we create a new pane and inside it put an `<iframe src="http://localhost:XYZ">`, we might be able to display Fava‚Äôs web UI right within Obsidian. There are some unknowns:
- **Content Security Policy:** Obsidian might block or sandbox iframes, especially pointing to localhost. We might need to ensure the plugin‚Äôs iframe has the right attributes or use the HTML sanitizer in Obsidian‚Äôs Markdown renderer (which likely strips iframes by default). However, Obsidian does allow iframes through HTML code blocks if `iframe` is in the HTML whitelist settings (some users embed YouTube etc.). We as a plugin might do it through the programmatic interface though.
- **Interaction:** If in an iframe, Fava would be fully functional but some keyboard interactions might interfere (Obsidian key bindings vs the web content). Ideally, it should largely work as it does in a normal browser.
- **Responsiveness:** Fava‚Äôs UI might not fit well in a narrow pane, but if given a full pane it should be fine. The user can always pop it out into a separate window if needed by just using the browser.

Another approach is to use an Electron BrowserWindow (since Obsidian is Electron). But since we‚Äôre in a plugin, we don‚Äôt have direct access to create new top-level windows (that‚Äôs internal to Obsidian).

There‚Äôs some precedent: a ‚ÄúCustom Frames‚Äù plugin exists that can embed external websites in Obsidian notes or panes. If that plugin can embed a local web app, maybe we can either recommend using it or mimic its technique. A Reddit thread discussed embedding local apps and concluded it‚Äôs tricky but possible via iframes if the app can be accessed via HTTP [oai_citation:54‚Ä°reddit.com](https://www.reddit.com/r/ObsidianMD/comments/13o3n4s/embedding_local_applications_in_the_context_of/#:~:text=,of%20a%20locally%20running%20app). Fava fits that description (a local HTTP server providing a web app). 

If we manage to embed Fava, that would allow users to, say, have their ledger note on one side and a live-updating Fava view on the other side within Obsidian. They could edit a transaction, save (plugin validates and also could reload Fava data if Fava picks up changes or if we restart it), and see updated charts in the next pane. This would be a killer feature for power users, though it might be complex to implement seamlessly.

### Option 3: Partial Integration or Data Exchange  
If full UI embedding is too difficult, we could consider smaller integrations:
- For example, generate a static chart image from Fava or a Python script and embed that in a note. (E.g., produce a PNG of an income over time graph and embed it in a dashboard note). But static images are not interactive or timely without manual refresh.
- Or use Fava‚Äôs JSON API (if it has one) to fetch certain data. It‚Äôs primarily a web app, but maybe some parts can be accessed via HTTP calls (not sure if Fava provides an API endpoints for data ‚Äì possibly not explicitly, but one could scrape its JSON from the web UI calls).
- A simpler integration: just create quick links from Obsidian to Fava pages. For instance, in the plugin‚Äôs account suggestions or error messages, offer a link ‚ÄúView in Fava‚Äù that, when clicked, opens the default browser to the Fava page for that account or report.

### Feasibility Summary for Fava  
Integrating Fava is certainly **feasible as an external launch**, and likely **possible as an embed** with some effort. The user should be made aware that Fava requires the Beancount Python environment. We might include in the README instructions to install Fava (`pip install fava`) if they want to use that feature.

Performance-wise, Fava runs its own server and reads the ledger ‚Äì if our plugin is also reading/modifying the ledger, they will need to play nicely. Possibly we would advise turning off Fava‚Äôs auto-reload, or the plugin would restart the Fava process when file changes (or rely on Fava‚Äôs own file watcher).

One more consideration: **Mobile**. Obsidian mobile can run community plugins, but it cannot easily spawn arbitrary processes like running Python. So Fava integration might be desktop-only. We should conditionally disable or hide that feature on mobile, or provide an alternate approach (maybe allow specifying an external Fava instance URL if they have one running on a server).

Given these complexities, our initial implementation might focus on the simple route: a command to open Fava externally. It addresses the user‚Äôs request of ‚Äúoptionally integrate with Fava‚Äù in a straightforward way. Full embedding can be a stretch goal if time permits or in a later plugin update.

## Proposed Plugin Architecture & Components

Bringing together the above considerations, here is a proposed design for the plugin‚Äôs architecture, along with its file structure and key components. This will serve as a scaffold for implementation.

### High-Level Architecture  
We can break the plugin‚Äôs functionality into a few logical modules:
1. **Core Plugin Class (`BeancountPlugin`)** ‚Äì Extends Obsidian‚Äôs Plugin API class. Responsible for initializing everything: setting up commands, loading settings, and orchestrating other components. On plugin load, it might scan the vault for designated ledger files or load the main file content.
2. **Settings & Configuration** ‚Äì A class or object to hold user settings (e.g., `Main Beancount File path`, `Default account for unspecified posting`, `Default currency`, `EnableDailyNotesIntegration`, `Path to Python/BeanCheck`, etc.). Also provides a UI (settings tab) to modify these.
3. **Beancount Data Manager** ‚Äì This could handle parsing or loading the ledger data. For instance, if we decide to parse the file ourselves for autocompletion, this manager would contain functions to:
   - Read the ledger file(s) and build lists of accounts, payees, commodities.
   - Potentially keep an in-memory representation of transactions (for quick querying or checking balances without always calling external tools).
   - Monitor file changes (Obsidian‚Äôs file events) to know when to re-parse or re-validate.
4. **Input UI (Transaction Modal)** ‚Äì Code for the ‚ÄúAdd Transaction‚Äù modal. This includes form fields and logic to assemble the user‚Äôs input into a valid transaction string in Beancount format. It will use Data Manager for suggestions (e.g., get list of accounts for autocomplete dropdowns) and possibly for verifying that the transaction balances as the user fills it (for example, computing the difference if one amount is left blank).
5. **Editor Enhancements** ‚Äì Functions or classes that handle editor decoration: inserting error markers, doing the Markdown post-processing for comments, and possibly syntax highlighting. Some of this might hook into Obsidian‚Äôs Markdown renderer (for preview transformations) and some into the live editor (CodeMirror extensions).
6. **Query Engine** ‚Äì If we implement query code blocks, we need a processor that runs when such a code block is found. Obsidian allows registering a **Markdown code block processor** for a given language tag. We can register one for `beancount-query`. This processor function would take the query string (inside the code block) and replace it with the query results. It might call external `bean-query` or use the Data Manager‚Äôs in-memory data.
7. **Fava Integration** ‚Äì A small component that when triggered starts/stops Fava. It might keep track of the child process and port. If we embed, it also manages injecting the iframe.

These components will interact as follows: when the user edits a ledger file, the Editor Enhancements part will ensure comments are handled and may call Data Manager to update any caches (e.g., new account encountered). On save or on demand, Validation runs (likely via Data Manager or a separate Validator util that calls bean-check) and then Editor Enhancements uses results to mark errors. The Transaction Modal, when submitted, will append text to a file (using Obsidian‚Äôs file system API) and then perhaps immediately trigger a re-parse/validate. Queries will be handled during rendering of notes. Fava integration sits somewhat separate, invoked only when the user wants.

### Directory Layout & Key Files  
We can structure the plugin as follows (assuming a project name ‚Äúobsidian-beancount‚Äù): 

| File/Directory              | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `package.json`              | Project metadata and dependencies (will include Obsidian API typings, possibly `shelljs` or other node libs for running commands, etc.)                                                                                                                                                                                                                                                                                                                                                                                                      |
| `manifest.json`             | Obsidian manifest with `id` (e.g., ‚Äúobsidian-beancount‚Äù), `name` (e.g., ‚ÄúBeancount Plugin‚Äù), version, author, `minAppVersion`, and the entry `main` script (compiled JS). Also lists any required permissions (if any).                                                                                                                                                                                                                                                                                                                      |
| `styles.css`                | Optional CSS for styling plugin elements (could style code blocks or error highlights if not done via CM6 directly).                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `main.ts`                   | Entry point TypeScript file. Instantiates the `BeancountPlugin` class and exports it. In `onload`, it will create instances of other classes, register commands, etc. In `onunload`, it should clean up (e.g., kill Fava process if running, remove decorations).                                                                                                                                                                                                                                                                            |
| `src/BeancountPlugin.ts`    | (If we separate from main) Defines the main plugin class extending `Plugin`. It would handle loading settings, initializing modules (data manager, etc.), and tie together command callbacks.                                                                                                                                                                                                                                                                                                                                                |
| `src/settings.ts`           | Contains the `Settings` data structure and `SettingsTab` class for Obsidian. This will create a nice UI in Obsidian‚Äôs settings panel where users can set options: e.g., text fields for file paths, toggles for features, etc.                                                                                                                                                                                                                                                                                                               |
| `src/dataManager.ts`        | Implements parsing of Beancount files (likely via regex or maybe by invoking a Python script for complex cases). It could also manage the cached data (accounts list, etc.). If using external processes for validation or query, this module could contain the functions that call them (to keep those details isolated). For example, a method `validateLedger(): ValidationResult` that runs `bean-check` and returns structured errors, and a method `queryLedger(query: string): QueryResult` that runs `bean-query` or internal logic. |
| `src/transactionModal.ts`   | Defines the Modal subclass that shows the ‚ÄúAdd Transaction‚Äù form. It will use Obsidian‚Äôs Modal & Setting components (there‚Äôs a UI toolkit for forms in the API, or we build HTML directly). It likely interacts with DataManager for suggestions and uses Settings (default account or currency) to pre-fill some data. On submission, it formats the text and appends it to the ledger file using Obsidian‚Äôs file API.                                                                                                                      |
| `src/editorEnhancements.ts` | Could include multiple pieces:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  - A **PostProcessor** for Markdown preview (to render commented lines as nice headings or hide certain technical markers).
  - CodeMirror extension for live syntax highlighting (if simple enough to implement).
  - Logic for adding error markers: possibly a function that takes a list of errors (line numbers, messages) and adds decorations to the editor. Obsidian‚Äôs Editor class might allow adding line widgets or markers.
  - Possibly also handle the `registerCodeblockProcessor("beancount-query", ...)` here, since that‚Äôs a kind of rendering enhancement.
|
| `src/favaIntegration.ts` | (Optional file) Functions to start and stop Fava. It might spawn the process (using Node‚Äôs `spawn`) and listen for stdout/stderr (to catch the ‚ÄúRunning on http://localhost:‚Ä¶‚Äù message to get the port). Could also kill the process on unload. If embedding, this would also provide the HTML/iframe generator. |

Additionally, we‚Äôd have a `README.md` at the root (for GitHub and Obsidian publish) and possibly a `CHANGELOG.md`. The README is important for documentation and is often displayed in the Obsidian plugin gallery. We‚Äôll outline the README content shortly.

**Build setup:** We will use a bundler ‚Äì the official sample now uses `esbuild` (as seen by `esbuild.config.mjs` in the sample [oai_citation:55‚Ä°github.com](https://github.com/obsidianmd/obsidian-sample-plugin#:~:text=README)) which is very fast. Alternatively, Rollup is common (the Ledger plugin used Rollup with a config file [oai_citation:56‚Ä°github.com](https://github.com/tgrosinger/ledger-obsidian#:~:text=package)). We might lean on whatever the sample provides to keep things simple. We‚Äôll ensure TypeScript target is ES2020 or so, and that the `obsidian` types are included.

### README.md Outline (Documentation)  
Our README (and by extension the Obsidian plugin registry listing) should clearly explain how to use the plugin. Here‚Äôs an outline of sections to include, aligning with our features:

- **Title & Description:** e.g. ‚Äú# Beancount Plugin for Obsidian‚Äù followed by a brief description: *Write and manage your [Beancount](https://beancount.github.io) financial ledger directly in Obsidian.md. Log transactions in Markdown files with Beancount syntax, and get inline validation, auto-completion, and integration with the Fava financial dashboard.* (We should mention it‚Äôs plaintext accounting, perhaps reference plaintextaccounting.org for newbies [oai_citation:57‚Ä°reddit.com](https://www.reddit.com/r/ObsidianMD/comments/1hqbyh6/do_you_like_ledger_plugin_what_do_you_think_about/#:~:text=plaintextaccounting).)

- **Features:** A bullet list of key features, for example:
  - *Plaintext Accounting in Markdown:* Use `.md` files to store transactions and financial records, with full Beancount compatibility.
  - *Inline Validation:* Errors and balance mismatches are highlighted as you work, ensuring your books stay consistent [oai_citation:58‚Ä°reddit.com](https://www.reddit.com/r/ObsidianMD/comments/1hqbyh6/do_you_like_ledger_plugin_what_do_you_think_about/#:~:text=However%2C%20when%20comparing%20the%20Ledger,%28see%20Discussion%20on%20Github).
  - *Autocomplete & Quick Entry:* Autocomplete suggestions for accounts, payees, and commodities as you type. Quickly add new transactions with a pop-up form (on desktop or mobile) [oai_citation:59‚Ä°github.com](https://github.com/tgrosinger/ledger-obsidian#:~:text=,planned%20soon).
  - *Queries & Reports:* Run financial queries inside Obsidian and insert summary tables (e.g., monthly spending by category). (If Dataview integration is relevant, mention it here too.)
  - *Fava Integration:* Optionally launch or view the Fava web interface for rich interactive reports [oai_citation:60‚Ä°reddit.com](https://www.reddit.com/r/plaintextaccounting/comments/rmwfwm/question_about_beancount_and_ledger/#:~:text=beancount%20is%20much%20more%20restrictive,hledger%27s%20syntax%20is%20pretty%20flexible).
  - *Daily Notes Integration:* (If we implement it) Log daily expenses in your Daily notes; then batch export them to your main ledger file.  
  Each feature can be a sentence or two. We can draw from wording in similar plugins (e.g., Hledger Notes description [oai_citation:61‚Ä°obsidianstats.com](https://www.obsidianstats.com/plugins/hledger-notes#:~:text=The%20Hledger%20Notes%20plugin%20enables,tool%20serves%20users%20seeking%20to)).

- **Installation:** Instructions: Through Obsidian‚Äôs community plugins browser (once it‚Äôs published) ‚Äì search ‚ÄúBeancount‚Äù. Or via BRAT for beta. Include a note about requiring Beancount installed for some features (validation, Fava). Possibly link to Beancount‚Äôs site for how to install it.

- **Usage Guide:** This will be longer. We should explain:
  - *Setting up your Ledger File:* e.g., ‚ÄúCreate a new note (or designate an existing one) to hold your Beancount ledger. If you already have `.beancount` files, you can rename or copy them as `.md` into your vault. In the plugin settings, set the ‚ÄòMain Beancount File‚Äô path to point to your ledger (or the folder containing ledger files).‚Äù
  - *Entering Transactions:* Explain how to use the ‚ÄúAdd Transaction‚Äù command or the ribbon icon. Possibly include a screenshot of the modal (if allowed in README; if not, just describe). Mention the auto-suggest: ‚Äúas you type an account name, you‚Äôll see suggestions from your chart of accounts [oai_citation:62‚Ä°github.com](https://github.com/bzimor/obsidian_hledger#:~:text=,for%20thousands%2C%20%27m%27%20for%20millions).‚Äù
  - *Editing Manually:* If users can just type in the note, provide any tips like how to format a transaction, how to mark comments (e.g., ‚Äúuse `;` at line start for comments or headings‚Äù). Perhaps provide a small example ledger snippet in a code block for reference.
  - *Validation:* State that the plugin automatically checks the ledger on save (or how it‚Äôs triggered) and what an error looks like (e.g., red underline, hover for message). Mention common errors like imbalance or typos.
  - *Queries:* Demonstrate a basic query in a code block in the README (if the plugin supports that out-of-the-box). Or instruct how to use the command palette to run a quick query. We might include an example like querying expenses this month. If we decide to lean on Dataview, we‚Äôll instead provide an example Dataview JS snippet as an advanced tip.
  - *Fava:* Explain how to enable Fava (install it, set path, then use ‚ÄúOpen Fava‚Äù command). Make it clear that Fava runs locally and the plugin is just interfacing with it. If embedding is available, explain how to open the Fava pane.
  - *Daily Notes (if implemented):* Explain how to tag transactions in daily notes (maybe we require them in a specific section like under a heading ‚ÄúTransactions‚Äù so the plugin knows where to look) and how to export them. This is a complex feature, so if we don‚Äôt implement initially, we might omit for now.

- **Examples:** Possibly provide a short example of a Markdown ledger file with some Markdown elements (to show headings usage etc.) and confirm it works with Beancount. Also maybe an example query result embedded.

- **Compatibility:** Note which Obsidian version it requires (e.g., v1.0+). Also, note if it works on Mobile (we should ensure the quick-add form is mobile-friendly ‚Äì Obsidian‚Äôs UI components usually are).

- **Acknowledgements:** Give credit to tgrosinger‚Äôs Ledger plugin, plaintextaccounting.org, Beancount‚Äôs author (Martin Blais), etc., and perhaps Hledger Notes if we borrowed ideas. This shows community spirit and also hints at related tools users might want to check [oai_citation:63‚Ä°reddit.com](https://www.reddit.com/r/ObsidianMD/comments/1hqbyh6/do_you_like_ledger_plugin_what_do_you_think_about/#:~:text=You%20could%20start%20with%20something,with%20a%20pure%20plaintext%20aproach).

- **License:** As required (likely MIT or GPL depending on what we reuse; Ledger was GPL3, Hledger Notes is MIT [oai_citation:64‚Ä°github.com](https://github.com/bzimor/obsidian_hledger#:~:text=License), so we‚Äôll choose one accordingly).

This README will serve as the user-facing documentation. We can include links to official Beancount docs for advanced usage (for instance: ‚ÄúSee Beancount‚Äôs documentation [oai_citation:65‚Ä°reddit.com](https://www.reddit.com/r/plaintextaccounting/comments/rmwfwm/question_about_beancount_and_ledger/#:~:text=article%20about%20the%20differences%3A%20https%3A%2F%2Fbeancount,ledger) for the full query language reference and accounting concepts‚Äù).

### Development & Tech Stack Recap  
To ensure the project is VSCode-friendly: we‚Äôll use TypeScript (with Obsidian‚Äôs typings) so VSCode autocompletion works. The file structure and build config should be similar to the official sample, which is known to integrate well with VSCode‚Äôs debugging (you can attach debugger to Obsidian, etc.). We might include an `.vscode/launch.json` to help run a development vault for testing (some plugin authors do that). The use of modern JS (ESNext) and async/await for processes will keep the code clean. We will also leverage libraries if needed: e.g., if implementing fuzzy search for accounts, we might pull in a small library like Fuse.js for fuzzy matching, or just use simple regex matching since the list of accounts isn‚Äôt huge. 

Testing can be done manually in Obsidian. If we were to write automated tests for, say, the parsing functions or formatting functions, we could set up Jest with the Obsidian API types mocked (some plugins have done this, as referenced in the Obsidian developer forums [oai_citation:66‚Ä°dev.to](https://dev.to/bjarnerentz/journey-developing-an-obsidian-plugin-part-1-getting-started-53m6#:~:text=This%20is%20not%20a%20tutorial,and%20publishing%20an%20Obsidian%20plugin)). This is optional but would improve reliability.

## Conclusion  
Building a Beancount integration plugin for Obsidian is **feasible** and would fill a niche for users who want to manage finances in their note-taking app. By drawing on existing plaintext accounting plugins and Beancount‚Äôs tools, we can implement a comprehensive solution. We have outlined how to handle the major challenges: keeping the data in Markdown without breaking Beancount‚Äôs parser, providing interactive input and validation, enabling analysis via queries, and even hooking into powerful external apps like Fava. 

This project scaffold lays out the major components and how they interplay. The next steps would involve prototyping the core features (especially the parsing/validation pipeline and the transaction entry modal) and incrementally adding enhancements like queries and Fava integration. With careful attention to usability and leveraging official docs and examples, the Obsidian Beancount plugin can become an invaluable tool for plain text accounting enthusiasts, letting them **‚Äúbalance their books‚Äù** in the same space where they plan and reflect on their lives.

**Sources & References:** This design was informed by Obsidian‚Äôs developer documentation [oai_citation:67‚Ä°github.com](https://github.com/obsidianmd/obsidian-sample-plugin#:~:text=This%20is%20a%20sample%20plugin,md) [oai_citation:68‚Ä°github.com](https://github.com/obsidianmd/obsidian-sample-plugin#:~:text=Quick%20starting%20guide%20for%20new,plugin%20devs), existing open-source plugins (tgrosinger‚Äôs Ledger [oai_citation:69‚Ä°github.com](https://github.com/tgrosinger/ledger-obsidian#:~:text=Personal%20finance%20tracking%20and%20planning%2C,in%20your%20Obsidian%20Vault%20instead) [oai_citation:70‚Ä°github.com](https://github.com/tgrosinger/ledger-obsidian#:~:text=,planned%20soon), bzimor‚Äôs Hledger Notes [oai_citation:71‚Ä°github.com](https://github.com/bzimor/obsidian_hledger#:~:text=Transaction%20Management) [oai_citation:72‚Ä°github.com](https://github.com/bzimor/obsidian_hledger#:~:text=Daily%20Notes%20Integration), hamsterbase‚Äôs obsidian-beancount [oai_citation:73‚Ä°github.com](https://github.com/hamsterbase/obsidian-beancount#:~:text=Use%20Obsidian%20on%20the%20phone,saving%20transaction%20to%20Beancount%20file)), and community discussions about plaintext accounting in Obsidian [oai_citation:74‚Ä°reddit.com](https://www.reddit.com/r/ObsidianMD/comments/17ef2wx/obsidian_modal_form_plugin_for_plain_text/#:~:text=uses%20text%20file%20and%20I,md%20format) [oai_citation:75‚Ä°reddit.com](https://www.reddit.com/r/plaintextaccounting/comments/rmwfwm/question_about_beancount_and_ledger/#:~:text=beancount%20is%20much%20more%20restrictive,hledger%27s%20syntax%20is%20pretty%20flexible). These resources provide real-world insights into implementing such features and ensure our approach aligns with proven practices.